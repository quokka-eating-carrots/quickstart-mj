# 리덕스를 이용한 상태 관리

## 플럭스 (flux)

대규모 애플리케이션에서 일관된 데이터 관리를 손쉽게 하기 위해 만들어진 단방향 데이터 처리 과정을 가지는 아키텍처. 플럭스 아키텍처는 단일 디스패처를 이용. 모든 데이터 흐름은 단일 디스패처를 거쳐 가므로 이곳에서만 모니터링과 로깅을 하면 모든 액션의 흐름을 볼 수 있으며, 액션에 의해 상태가 어떻게 변경돼가는지를 손쉽게 추적 가능.

1. 뷰 컴포넌트(리액트 컴포넌트)에서 이벤트가 발생하면 이벤트 핸들러에 의해 액션 생성자(ActionCreator)가 호출.
2. 액션 생성자는 외부 API 호출과 같은 부작용 (side effect) 처리를 수행하고 수행 결과를 action이라는 일종의 객체 형태의 메시지를 생성하여 디스패처(dispatcher)에 전달. `{type: "addTodo", payload: {todo: "공부하기", desc: "리덕스"}}`
3. 디스패처는 액션을 스토어에 전달. 스토어는 액션 정보를 이용해 지정된 상태 변경 작업을 수행.
4. 상태가 변경되면 각 스토어와 연결된 컴포넌트의 UI가 갱신.

## 리덕스 (Redux)

리덕스는 댄 아브라모프라는 개발자가 만든 자바스크립트 애플리케이션을 위한 예측 가능한 상태 관리 컨테이너. 플럭스의 기능과 더불어 핫 리로딩 (hot reloading), 시간 여행 디버깅(time travel debugging)과 같은 기능을 제공.<br />
리덕스의 스토어는 상태만 가지고 상태 변경의 기능을 리듀서라는 요소로 분리. 이 결과 변경 로직이 개발 중에 변경되더라도 상태를 유지시킬 수 있다. 이 기능을 **핫 리로딩**이라고 한다. 리듀서를 이용해 상태를 변경할 때 기존 상태 객체를 변경하지 않고 새로운 상태 객체를 생성한다.<br />
리덕스의 불변성을 가지는 상태 변경은 시간 흐름에 따라 상태의 이력을 남긴다. 상태 변경 이력은 시간 흐름에 따라 상태가 어떻게 변경됐는지 손쉽게 추적할 수 있게 해 준다. 그리고 애플리케이션 개발 중에 과거의 어느 한 시점의 상태로 돌아가서 다시 기능을 확인할 수 있어 디버깅에 유용하다. 이런 디버깅 기능을 **시간 여행 디버깅**이라고 한다.

### 리덕스 아키텍처와 처리 과정

1. 스토어의 상태와 액션 생성자를 이용한 디스패치 기능의 함수가 주입된 뷰 컴포넌트에서 이벤트가 발생.
2. 뷰 컴포넌트의 이벤트 핸들러는 속성으로 주입된 함수가 호출되며, 이때 action을 만들어서 스토러오 전달(dispatch). 액션의 형태는 플럭스 아키텍처에서 사용하던 것과 유사.
3. 스토어는 전달받은 액션과 자신의 상태를 리듀서 함수의 인자로 전달. 리듀서는 다음과 같은 형식의 함수. `(state, action) => {...}`
4. 리듀서는 인자로 전달받은 상태는 변경하지 않고, action을 이용해 새로운 상태를 만든 뒤 리턴 합니다.
5. 스토어는 리듀서가 리턴한 상태를 새로운 상태로 설정. 스토어의 새로운 상태는 뷰 컴포넌트에 연결되어 있으므로 화면이 새롭게 렌더링 된다.

### 리덕스 구성 요소

리덕스 아키텍처에서 스토어는 단 하나이다. 스토어의 상태는 읽기 전용, 상태 변경은 리듀서에 의해서만 수행해야 한다. 리듀서는 여러 개 만들 수 있는데 상태 변경 로직을 포함하면서 더불어 스토어가 가지는 초기 상태를 전달해 주는 역할을 한다. 리듀서는 **순수 함수**여야 한다.

## 다중 리듀서

## 리덕스 미들웨어

액션이 스토어로 전달된 후 리듀서에 도달하기 전과 상태 변경이 완료된 후에 수행할 중앙집중화된 작업을 지정할 수 있는 함수. 리덕스 미들웨어는 스토어 내부에 등록한다. 리덕스가 단일 스토어 아키텍처이기 때문에 스토어에 들여다 볼 수 있는 요소를 설치하면 모니터링, 비동기, 로깅 등의 다양한 작업을 수행할 수 있는데, 스토어에 설치하는 요소가 리덕스 미들웨어이다.

`middleware(store)(next)(action)` 이런 형태의 커링 함수(curring)를 사용하게 되는데 store는 리덕스 스토어, action은 스토어로 전달되는 액션 메시지, next는 dispatch() 함수이다. 한 미들웨어에서 리듀서로 전달하기 전의 실행이 완료되면 next(action)을 호출하여 다음 리듀서로 action을 전달해 줄 수 있다. 만약 액션을 전달해 주지 않으면 다음 미들웨어는 물론이고 리듀서로 액션이 전달되지 않으므로 상태를 변경하지 않을 것이다.

미들웨어를 추가하려면 순서대로 concat()함수로 추가한다.

@reduxjs/toolkit은 직렬화 가능 여부, 불변성 제공 여부를 체크하는 내장된 기본 미들웨어와 비동기 처리를 위한 redux-thunk 기능을 제공하는 미들웨어를 내장하고 있다. 해당 프로젝트의 Date 타입을 사용하는 currentTime은 직렬화가 지원되지 않으므로 경고가 발생할 수 있으므로 serializableCheck 옵션을 false로 지정하였다.

loggerMW의 내용을 개발할 때 확인할 수 있는 것

- 전달된 액션
- 전달된 액션에 의해 변경되기 전의 상태
- 전달된 액션에 의해 변경된 후의 상태

## redux-thunk 미들웨어

리듀서는 비동기 처리 코드를 배치하지 않는다. 왜냐하면 리듀서는 상태를 변경하는 기능만을 작성해야 하며, 순수 함수여야 하기 때문이다. redux-thunk는 액션 대신에 thunk라는 함수를 전달(dispatch)하도록 하여 비동기 처리를 수행하는 기능을 제공하는 미들웨어이다. 지연된 연산을 실행하기 위해 표현식으로 만든 함수라고 할 수 있다.

1. dispatch(action)이 호출되면서 스토어로 액션이 전달.
2. redux-thunk 미들웨어를 거치면서 전달된 액션이 thunk 형태의 함수인지를 확인.
3. 이때 thunk라면 thunk() 함수 내부에서 비동기 처리 코드를 실행, 이 과정에서 상태를 변경할 수 있는 액션을 전달.

- 이 함수 내부에서 비동기 처리가 시작되었음을 나타내기 위한 상태 변경 액션을 전달(dispatch)
- 비동기 처리가 완려되면 처리 결과를 화면에 나타내기 위한 상태 변경 액션을 전달(dispatch)

4. thunk가 아니라면 next(action)을 호출해 리듀서가 새로운 상태를 만들어내도록 한다.

### createAsyncThunk() 사용 방법

```javascript
const asyncAction = createAsyncThunk("액션명", asnyc (arg, thunkAPI) => {
  // arg는 비동기 처리할 때 필요한 아규먼트
  // 비동기 처리 후 마지막에 리턴 하는 값이 최종적으로 완료했을 때 전달하는 action의 페이로드가 된다.
  return payload
})
```

createAsyncThunk 툴킷 함수의 특징은 시점별로 직접 dispatch(action) 하지 않아도 된다는 것.
리턴 받은 함수의 이름이 `asyncAction` 이고 액션명이 `searchPerson`으로 지정했다면 각 시점의 액션 생성자 함수와 액션이 사용하는 액션명은 아래와 같다.
| 시점 | 액션명 | 액션 생성자 함수 |
| -- | -- | -- |
| 비동기 작업 시작 | searchPerson/pending | asyncAction.pending |
| 비동기 작업 완료 | searchPerson/fulfilled | asyncAction.fulfilled |
| 비동기 작업 실패 | searchPerson/rejected | asyncAction.rejected |

createAsyncThunk() 람수에 전달되는 두 번째 인자인 payloadCreator 함수는 Promise 기반이므로 async/await이나 Promise 기반으로 작성해야 한다.

[백엔드 API 요청 redux-thunk와 axios 사용하기]("https://bit.ly/redux-thunk-tk")

## redux-saga 미들웨어

액션 생성자로부터 분리하여 손쉽게 관리할 수 있도록 만들어진 리덕스 미들웨어. 리덕스 스토어의 흐름을 들여다 보고 있다가 특정 액션이 감지되면 지정한 saga데 의해 작업이 시작, 중지, 취소되로록 정의할 수 있다.

saga는 마이크로 서비스 환경에서 분산된 서비스가 제공하는 기능들을 트랜잭션 단위로 처리하기 위해서 만들어진 개념. 여러 개별 트랜잭션의 순서가 있는 집합.

redux-saga를 사용하려면 제너레이터에 대한 이해가 필요하다. 제너레이터는 yield문을 이용해 실행의 제어권을 제너레이터 함수 밖으로 넘겼다가 다시 돌려받을 수 있는 함수이다.

### saga의 효과

- takeEvery: 들어오는 모든 액션을 감시, 액션이 포착되면 지정된 작업자 사가를 실행.
- delay: 원하는 시간만큼 실행을 지연.
- put: 액션을 전달(dispatch)
- fork: 새로운 사가 작업을 시작.
- call: 함수를 동기적으로 시작하고 Promise가 완료될 때까지 블로킹 상태로 대기.
- select: 상태로부터 필요한 데이터를 읽어온다.
- all: 여러 개의 제너레이터를 배열로 전달하면 병렬로 실행하고 모두 완료될 때까지 대기.
- join: 다른 작업이 완료될 때까지 대기.

## react-redux가 제공하는 훅

- useStore(): 리덕스 스토어 객체를 리턴. 스토어의 상태를 읽어내려면 이 객체의 getState() 함수를 이용.
- useDispatch(): 스토어의 dispatch() 함수를 리턴. 리턴 받은 함수를 이용해 액션을 스토어로 전달.
- useSelector(): 리덕스 스토어의 특정 상태를 선택하여 리턴.
